<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Win While They're Singing — Spotify Host (PKCE)</title>
    <style>
      body {
        font-family: Inter, system-ui, Arial, sans-serif;
        background: #071020;
        color: #e6eef6;
        margin: 0;
        padding: 20px;
      }
      /* FIX: Make the wrapper relative for absolute positioning of labels */
      .wrap {
        max-width: 980px;
        margin: 0 auto;
        position: relative;
      }
      h1 {
        margin: 0 0 8px;
      }
      .muted {
        color: #9aa6b2;
        font-size: 13px;
      }
      input,
      button,
      select {
        padding: 8px;
        border-radius: 8px;
        border: 1px solid rgba(255, 255, 255, 0.04);
        background: transparent;
        color: inherit;
      }
      button {
        cursor: pointer;
        background: linear-gradient(90deg, #06b6d4, #7dd3fc);
        color: #022;
        padding: 8px 12px;
        font-weight: 700;
      }
      .controls {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        margin: 12px 0;
      }
      .panel {
        background: rgba(255, 255, 255, 0.02);
        padding: 12px;
        border-radius: 10px;
        margin-bottom: 12px;
      }

      /* New Label Container FIX: Position relative to the progressWrap's position */
      #markerLabels {
        position: absolute;
        /* PULL DOWN labels container to ensure visibility */
        top: -40px;
        left: 20px;
        right: 20px;
        height: 40px;
        z-index: 30;
      }

      /* Progress Bar Container */
      #progressWrap {
        position: relative;
        height: 56px;
        background: #1f2937;
        border-radius: 8px;
        overflow: visible;
        border: 1px solid rgba(255, 255, 255, 0.1);
        display: none;
        margin-top: 45px;
      }
      #bar {
        position: absolute;
        left: 0;
        top: 0;
        bottom: 0;
        background: linear-gradient(90deg, #10b981, #34d399);
        width: 0%;
        opacity: 0.9;
      }

      /* Marker Styles (The vertical line inside the progress bar) */
      .markers {
        position: absolute;
        left: 0;
        right: 0;
        top: 0;
        bottom: 0;
      }
      .marker {
        position: absolute;
        top: 0;
        width: 2px;
        height: 100%;
        background: #4b5563;
        opacity: 0.6;
        transition: all 0.2s ease-out;
        z-index: 10;
      }

      /* Pulse animation definition */
      @keyframes pulse {
        0% {
          box-shadow: 0 0 0 0 rgba(245, 158, 11, 0.4);
        }
        70% {
          box-shadow: 0 0 0 10px rgba(245, 158, 11, 0);
        }
        100% {
          box-shadow: 0 0 0 0 rgba(245, 158, 11, 0);
        }
      }

      /* Active marker style - triggered by JS */
      .marker.active {
        background: #f59e0b;
        width: 4px;
        opacity: 1;
        animation: pulse 0.5s ease-out;
        box-shadow: 0 0 8px #f59e0b;
      }

      /* Marker Label (the text) */
      .markerLabel {
        position: absolute;
        transform: translateX(-50%);
        background: #071020;
        border: 1px solid rgba(255, 255, 255, 0.1);
        padding: 2px 4px;
        border-radius: 4px;
        font-size: 12px;
        color: #dff8fb;
        white-space: nowrap;
        text-align: center;
        z-index: 20;
      }

      /* Active label color change */
      .markerLabel.active {
        color: #f59e0b;
        font-weight: 700;
      }

      .buzzList {
        margin-top: 8px;
      }
      .buzzItem {
        display: flex;
        justify-content: space-between;
        padding: 6px;
        background: rgba(255, 255, 255, 0.02);
        border-radius: 6px;
        margin-bottom: 6px;
      }
      .note {
        font-size: 13px;
        color: #9aa6b2;
      }
    </style>
  </head>
  <body>
    <div class="wrap">
      <h1>Win While They're Singing — Spotify (Host)</h1>

      <div class="muted">
        Spotify-only host mode. Now using the recommended **Authorization Code
        Flow with PKCE**.
      </div>

      <div class="panel">
        <div
          style="display: flex; gap: 8px; align-items: center; flex-wrap: wrap"
        >
          <input
            id="clientId"
            placeholder="Paste your Spotify Client ID here"
            style="min-width: 320px"
          />
          <button id="loginBtn">Log in to Spotify</button>
          <button id="logoutBtn" style="background: #f87171">Log out</button>
        </div>

        <div class="note" style="margin-top: 8px">
          Redirect URI used: <span id="redirectShown"></span>
        </div>
      </div>

      <div class="panel">
        <div
          style="display: flex; gap: 8px; align-items: center; flex-wrap: wrap"
        >
          <input
            id="trackInput"
            placeholder="Paste Spotify track URL or URI"
            style="min-width: 320px"
          />
          <button id="loadTrack">Load Track</button>
        </div>

        <div class="note" style="margin-top: 8px">
          After loading, press <strong>Play</strong> below to start playback on
          this browser device (host account).
        </div>

        <div class="controls" style="margin-top: 8px">
          <button id="playBtn">Play</button>
          <button id="pauseBtn">Pause</button>
          <button id="seekStartBtn">Seek to 0</button>
        </div>
      </div>

      <div class="panel">
        <div class="controls">
          <button id="startRound">
            Start Round (start playback & enable buzz)
          </button>

          <button id="buzzBtn" style="background: #f97316">
            Buzz (spacebar)
          </button>
          <button id="replayBtn">Replay + Reveal</button>
          <button id="resetBtn" style="background: #94a3b8">
            Reset Buzzes
          </button>
        </div>

        <div class="note" style="margin-top: 8px">
          When buzzing, you'll be prompted for the player's name (simple
          single-host input).
        </div>

        <div class="buzzList" id="buzzList"></div>
      </div>

      <div id="markerLabels"></div>
      <div id="progressWrap" class="panel">
        <div id="bar"></div>

        <div class="markers" id="markers"></div>
      </div>

      <div class="panel">
        <div><strong>State</strong></div>

        <div class="note" id="stateInfo" style="margin-top: 8px">
          Not logged in
        </div>
      </div>

      <div class="note" style="margin-top: 12px">
        Notes: This app uses the Spotify Web Playback SDK to run audio
        in-browser (host).
      </div>
    </div>

    <script>
      // --- PKCE Helper Functions ---

      function generateRandomString(length) {
        let text = "";
        const possible =
          "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
        for (let i = 0; i < length; i++) {
          text += possible.charAt(Math.floor(Math.random() * possible.length));
        }
        return text;
      }

      async function generateCodeChallenge(codeVerifier) {
        const data = new TextEncoder().encode(codeVerifier);
        const digest = await window.crypto.subtle.digest("SHA-256", data);
        return btoa(
          String.fromCharCode.apply(null, [...new Uint8Array(digest)])
        )
          .replace(/\+/g, "-")
          .replace(/\//g, "_")
          .replace(/=+$/, "");
      }

      // --- Main App Logic ---

      const CLIENT_ID_INPUT = document.getElementById("clientId");
      const loginBtn = document.getElementById("loginBtn");
      const logoutBtn = document.getElementById("logoutBtn");
      const redirectShown = document.getElementById("redirectShown");

      const scopes = [
        "streaming",
        "user-read-email",
        "user-read-private",
        "user-modify-playback-state",
        "user-read-playback-state",
      ].join(" ");

      // Full URL without hash (used as redirect_uri)
      const redirectUri = window.location.href.split("#")[0].split("?")[0];
      redirectShown.textContent = redirectUri;

      const AUTH_URL = "https://accounts.spotify.com/authorize";
      const TOKEN_URL = "https://accounts.spotify.com/api/token";
      const API_BASE_URL = "https://api.spotify.com/v1";

      let ACCESS_TOKEN = null;
      let EXPIRES_AT = 0;
      let REFRESH_TOKEN = null;

      let player = null;
      let deviceId = null;

      const loadTrackBtn = document.getElementById("loadTrack");
      const trackInput = document.getElementById("trackInput");
      const playBtn = document.getElementById("playBtn");
      const pauseBtn = document.getElementById("pauseBtn");
      const seekStartBtn = document.getElementById("seekStartBtn");

      const startRoundBtn = document.getElementById("startRound");
      const buzzBtn = document.getElementById("buzzBtn");
      const replayBtn = document.getElementById("replayBtn");
      const resetBtn = document.getElementById("resetBtn");
      const buzzListEl = document.getElementById("buzzList");

      const progressWrap = document.getElementById("progressWrap");
      const bar = document.getElementById("bar");
      const markers = document.getElementById("markers");
      const markerLabels = document.getElementById("markerLabels"); // <-- ADD THIS LINE
      const stateInfo = document.getElementById("stateInfo");

      let buzzes = []; // {name, time_ms}
      let roundActive = false;
      let revealRAF = null;

      // --- Core PKCE Functions ---

      // Step 1: Redirect to Authorization
      async function buildAuthUrl(clientId) {
        const codeVerifier = generateRandomString(128);
        const codeChallenge = await generateCodeChallenge(codeVerifier);

        // Store verifier for later exchange
        localStorage.setItem("code_verifier", codeVerifier);

        const params = new URLSearchParams({
          client_id: clientId,
          response_type: "code", // <-- Requesting a code, not a token
          redirect_uri: redirectUri,
          scope: scopes,
          code_challenge_method: "S256",
          code_challenge: codeChallenge,
          show_dialog: "true",
          state: generateRandomString(16), // Optional but recommended
        });
        return AUTH_URL + "?" + params.toString();
      }

      // Step 2: Exchange Code for Token
      async function exchangeCodeForToken(clientId, code, codeVerifier) {
        const body = new URLSearchParams({
          grant_type: "authorization_code",
          code: code,
          redirect_uri: redirectUri,
          client_id: clientId,
          code_verifier: codeVerifier, // PKCE element
        });

        const response = await fetch(TOKEN_URL, {
          method: "POST",
          headers: { "Content-Type": "application/x-www-form-urlencoded" },
          body: body,
        });

        if (!response.ok) {
          throw new Error(
            "Token exchange failed: " +
              response.status +
              " " +
              (await response.text())
          );
        }

        return response.json();
      }

      // Step 3: Refresh Token
      async function refreshToken(clientId, storedRefreshToken) {
        const body = new URLSearchParams({
          grant_type: "refresh_token",
          refresh_token: storedRefreshToken,
          client_id: clientId, // Required for PKCE refresh
        });

        const response = await fetch(TOKEN_URL, {
          method: "POST",
          headers: { "Content-Type": "application/x-www-form-urlencoded" },
          body: body,
        });

        if (!response.ok) {
          console.error("Token refresh failed");
          throw new Error("Token refresh failed: " + response.status);
        }

        return response.json();
      }

      // --- Initialization and Event Handlers ---

      loginBtn.onclick = async () => {
        const clientId = CLIENT_ID_INPUT.value.trim();
        if (!clientId) return alert("Paste your Spotify Client ID first");
        localStorage.setItem("spotify_client_id", clientId);
        try {
          const url = await buildAuthUrl(clientId);
          console.log("Redirecting to Spotify auth URL (PKCE):", url);
          window.location = url;
        } catch (e) {
          console.error(e);
          alert("Could not generate PKCE challenge. Check console.");
        }
      };

      logoutBtn.onclick = () => {
        ACCESS_TOKEN = null;
        EXPIRES_AT = 0;
        REFRESH_TOKEN = null;
        localStorage.removeItem("spotify_access_token");
        localStorage.removeItem("spotify_expires_at");
        localStorage.removeItem("spotify_client_id");
        localStorage.removeItem("spotify_refresh_token");
        localStorage.removeItem("code_verifier");
        stateInfo.textContent = "Logged out";
        alert(
          "Logged out locally. To fully revoke use Spotify account settings."
        );
        // Reload page to clear player
        window.location.reload();
      };

      // Handle redirection from Spotify (contains 'code' in query params)
      async function initFromCallback() {
        console.log("Initializing Spotify auth...");

        const urlParams = new URLSearchParams(window.location.search);
        const authCode = urlParams.get("code");
        const storedCid = localStorage.getItem("spotify_client_id");

        if (authCode && storedCid) {
          const codeVerifier = localStorage.getItem("code_verifier");
          if (!codeVerifier) {
            stateInfo.textContent = "Auth failed: Missing code verifier.";
            history.replaceState(null, "", redirectUri);
            return;
          }

          stateInfo.textContent = "Exchanging authorization code for tokens...";
          try {
            const tokenData = await exchangeCodeForToken(
              storedCid,
              authCode,
              codeVerifier
            );

            // Store tokens
            ACCESS_TOKEN = tokenData.access_token;
            REFRESH_TOKEN = tokenData.refresh_token;
            const expires_in = parseInt(tokenData.expires_in || 3600, 10);
            EXPIRES_AT = Date.now() + expires_in * 1000;

            localStorage.setItem("spotify_access_token", ACCESS_TOKEN);
            localStorage.setItem("spotify_expires_at", EXPIRES_AT);
            if (REFRESH_TOKEN)
              localStorage.setItem("spotify_refresh_token", REFRESH_TOKEN);
            localStorage.removeItem("code_verifier"); // Verifier is single-use

            stateInfo.textContent = "Logged in successfully via PKCE.";
            history.replaceState(null, "", redirectUri); // Clean URL

            loadSpotifySDKAndInit();
          } catch (e) {
            stateInfo.textContent = "Token exchange failed. See console.";
            console.error(e);
          }
        } else {
          // Load stored tokens if no auth code in URL
          const storedToken = localStorage.getItem("spotify_access_token");
          const exp = parseInt(
            localStorage.getItem("spotify_expires_at") || "0",
            10
          );
          const rToken = localStorage.getItem("spotify_refresh_token");

          if (storedToken && exp && Date.now() < exp) {
            ACCESS_TOKEN = storedToken;
            EXPIRES_AT = exp;
            REFRESH_TOKEN = rToken;
            stateInfo.textContent = "Using stored access token.";
            loadSpotifySDKAndInit();
          } else if (rToken && storedCid) {
            // Token expired, but we have a refresh token
            stateInfo.textContent = "Token expired. Attempting to refresh...";
            try {
              const tokenData = await refreshToken(storedCid, rToken);

              ACCESS_TOKEN = tokenData.access_token;
              const expires_in = parseInt(tokenData.expires_in || 3600, 10);
              EXPIRES_AT = Date.now() + expires_in * 1000;
              // Refresh token may or may not be sent back. If it is, store it.
              if (tokenData.refresh_token)
                REFRESH_TOKEN = tokenData.refresh_token;

              localStorage.setItem("spotify_access_token", ACCESS_TOKEN);
              localStorage.setItem("spotify_expires_at", EXPIRES_AT);
              if (REFRESH_TOKEN)
                localStorage.setItem("spotify_refresh_token", REFRESH_TOKEN);

              stateInfo.textContent = "Token refreshed successfully.";
              loadSpotifySDKAndInit();
            } catch (e) {
              stateInfo.textContent = "Token refresh failed. Please log in.";
              console.error(e);
            }
          } else {
            stateInfo.textContent = "Not logged in (no valid token).";
          }
        }

        if (storedCid) CLIENT_ID_INPUT.value = storedCid;
      }

      // Save client id when changed (convenience)
      CLIENT_ID_INPUT.addEventListener("change", () =>
        localStorage.setItem("spotify_client_id", CLIENT_ID_INPUT.value.trim())
      );

      // load SDK script then init player when we have token
      function loadSpotifySDKAndInit() {
        if (!ACCESS_TOKEN) return;
        // load SDK if needed
        if (!window.Spotify) {
          const tag = document.createElement("script");
          tag.src = "https://sdk.scdn.co/spotify-player.js";
          document.head.appendChild(tag);
        }
        window.onSpotifyWebPlaybackSDKReady = () => {
          initializePlayer();
        };
        // attempt to initialize immediately if SDK already present
        if (window.Spotify && !player) initializePlayer();
      }

      async function initializePlayer() {
        if (!ACCESS_TOKEN) return;
        if (player) return;

        // Check if token is near expiration and try to refresh
        const THRESHOLD = 60000; // 60 seconds
        if (
          Date.now() + THRESHOLD > EXPIRES_AT &&
          REFRESH_TOKEN &&
          localStorage.getItem("spotify_client_id")
        ) {
          console.log(
            "Token close to expiry, attempting refresh before initializing player."
          );
          try {
            const clientId = localStorage.getItem("spotify_client_id");
            const tokenData = await refreshToken(clientId, REFRESH_TOKEN);
            ACCESS_TOKEN = tokenData.access_token;
            const expires_in = parseInt(tokenData.expires_in || 3600, 10);
            EXPIRES_AT = Date.now() + expires_in * 1000;
            if (tokenData.refresh_token)
              REFRESH_TOKEN = tokenData.refresh_token;
            localStorage.setItem("spotify_access_token", ACCESS_TOKEN);
            localStorage.setItem("spotify_expires_at", EXPIRES_AT);
            if (REFRESH_TOKEN)
              localStorage.setItem("spotify_refresh_token", REFRESH_TOKEN);
            stateInfo.textContent = "Token refreshed. Initializing player.";
          } catch (e) {
            console.error(
              "Failed to refresh token during player init. Player may fail."
            );
            stateInfo.textContent =
              "Refresh failed. Player may fail: " + e.message;
          }
        }

        player = new Spotify.Player({
          name: "WinWhileTheyreSinging — Host",
          getOAuthToken: (cb) => {
            cb(ACCESS_TOKEN);
          },
          volume: 0.8,
        });

        // ready
        player.addListener("ready", ({ device_id }) => {
          deviceId = device_id;
          stateInfo.textContent = "Player ready — device_id: " + device_id;
        });

        player.addListener("not_ready", ({ device_id }) => {
          console.warn("Device went offline", device_id);
          stateInfo.textContent = "Player went offline";
        });

        player.addListener("initialization_error", ({ message }) => {
          console.error(message);
          stateInfo.textContent = "Init error: " + message;
        });
        player.addListener("authentication_error", ({ message }) => {
          console.error(message);
          stateInfo.textContent = "Auth error: " + message;
        });
        player.addListener("player_state_changed", (state) => {
          /* console.log('player_state_changed', state); */
        });

        await player.connect();
      }

      // helper to call Spotify Web API endpoints
      async function apiFetch(path, opts = {}) {
        if (!ACCESS_TOKEN) throw new Error("No access token");
        // Simple check for expiration, though the player uses getOAuthToken.
        // This ensures API calls also use a valid token.
        if (Date.now() > EXPIRES_AT - 60000 && REFRESH_TOKEN) {
          console.warn("API call triggering token refresh.");
          await initFromCallback(); // Use the existing refresh logic
        }

        const res = await fetch(API_BASE_URL + path, {
          headers: {
            Authorization: "Bearer " + ACCESS_TOKEN,
            "Content-Type": "application/json",
          },
          ...opts,
        });
        if (!res.ok) {
          const text = await res.text();
          throw new Error("Spotify API " + res.status + " " + text);
        }
        return res.json().catch(() => null);
      }

      // load track (extract track URI)
      function extractUriOrUriFromUrl(text) {
        if (!text) return null;
        // If it's spotify:track:... return as-is
        if (text.startsWith("spotify:")) return text;
        try {
          const u = new URL(text);
          // https://open.spotify.com/track/{id}
          if (u.hostname.includes("open.spotify.com")) {
            const parts = u.pathname.split("/");
            const type = parts[1];
            const id = parts[2];
            if (type && id) return `spotify:${type}:${id.split("?")[0]}`;
          }
        } catch (e) {}
        // fallback: assume user supplied spotify:track:id
        return text;
      }

      let loadedTrackUri = null;
      loadTrackBtn.onclick = () => {
        const val = trackInput.value.trim();
        const uri = extractUriOrUriFromUrl(val);
        if (!uri) return alert("Paste a Spotify track URL or URI");
        loadedTrackUri = uri;
        stateInfo.textContent = "Loaded " + uri;
      };

      // play on our device
      async function playOnDevice(uri, position_ms = 0) {
        if (!ACCESS_TOKEN) return alert("Log in first");
        if (!deviceId) {
          alert(
            "Player not ready yet. Make sure the page prompted to start the Spotify player and you have Premium."
          );
          return;
        }
        const body = JSON.stringify({
          uris: [uri.replace("spotify:track:", "spotify:track:")],
          position_ms,
          offset: { position: 0 },
        });
        // Use play endpoint and specify device_id query
        const url = `https://api.spotify.com/v1/me/player/play?device_id=${deviceId}`;
        const res = await fetch(url, {
          method: "PUT",
          headers: {
            Authorization: "Bearer " + ACCESS_TOKEN,
            "Content-Type": "application/json",
          },
          body,
        });
        if (res.status === 204 || res.status === 202) return true;
        const txt = await res.text();
        throw new Error("Play failed: " + res.status + " " + txt);
      }

      playBtn.onclick = async () => {
        if (!loadedTrackUri) return alert("Load a track first");
        try {
          await playOnDevice(loadedTrackUri, 0);
          stateInfo.textContent = "Playing on host device";
        } catch (e) {
          alert("Play error: " + e.message);
          console.error(e);
        }
      };
      pauseBtn.onclick = async () => {
        if (!ACCESS_TOKEN || !deviceId) return;
        try {
          await fetch(
            `https://api.spotify.com/v1/me/player/pause?device_id=${deviceId}`,
            {
              method: "PUT",
              headers: { Authorization: "Bearer " + ACCESS_TOKEN },
            }
          );
          stateInfo.textContent = "Paused";
        } catch (e) {
          alert("Pause failed: " + e);
        }
      };
      seekStartBtn.onclick = async () => {
        if (!ACCESS_TOKEN || !deviceId) return;
        try {
          await fetch(
            `https://api.spotify.com/v1/me/player/seek?position_ms=0&device_id=${deviceId}`,
            {
              method: "PUT",
              headers: { Authorization: "Bearer " + ACCESS_TOKEN },
            }
          );
          stateInfo.textContent = "Seeked to start";
        } catch (e) {
          alert("Seek failed: " + e);
        }
      };

      // Start round: clears buzzes, plays and enables buzz button
      startRoundBtn.onclick = async () => {
        if (!loadedTrackUri) return alert("Load a track first");
        buzzes = [];
        renderBuzzList();
        progressWrap.style.display = "block";
        // start playback at 0
        try {
          await playOnDevice(loadedTrackUri, 0);
          roundActive = true;
          stateInfo.textContent = "Round started — buzzes enabled";
          // start progress loop (no reveal during recording)
          startRevealLoop(false);
        } catch (e) {
          alert("Could not start round: " + e.message);
          console.error(e);
        }
      };

      // Buzz: record current playback position via player.getCurrentState()
      buzzBtn.onclick = async () => {
        if (!roundActive) return alert("Round not active");
        if (!player) return alert("Player not initialized yet");
        const name = prompt("Who buzzed? (type player name)");
        if (!name) return;
        const state = await player.getCurrentState();
        if (!state)
          return alert(
            "Could not read player state (try interacting with the player first)"
          );
        const pos = state.position; // ms
        buzzes.push({
          name: name.trim(),
          time_ms: Math.max(0, Math.floor(pos)),
        });
        renderBuzzList();
      };

      // Replay + Reveal: seek to 0, show dim markers, and reveal/pulse them when hit
      replayBtn.onclick = async () => {
        if (buzzes.length === 0) return alert("No buzzes recorded");
        if (!deviceId) return alert("Device not ready");

        roundActive = false; // Disable buzzing during replay

        // CRITICAL CHANGE: Seek to start and play FIRST
        try {
          await playOnDevice(loadedTrackUri, 0);
          stateInfo.textContent = "Replaying for reveal...";
        } catch (e) {
          alert("Replay play error: " + e.message);
          return;
        }

        // 1. Clear and render dim markers
        markers.innerHTML = "";
        markerLabels.innerHTML = "";
        bar.style.width = "0%";

        const state = await player.getCurrentState();

        if (
          !state ||
          !state.track_window ||
          state.track_window.current_track == null
        ) {
          return alert("Could not get current track info after seek.");
        }
        const duration = state.duration; // ms

        // --- ZOOM FACTOR IMPLEMENTATION ---
        // The bar will only display the first 25% of the song.
        const ZOOM_FACTOR = 0.25;
        const MAX_DURATION_MS = duration * ZOOM_FACTOR;
        // --- END ZOOM FACTOR ---

        // Filter out buzzes that occur after the zoom window
        let visibleBuzzes = buzzes.filter((b) => b.time_ms <= MAX_DURATION_MS);

        if (visibleBuzzes.length === 0 && buzzes.length > 0) {
          alert(
            `Note: All ${buzzes.length} buzzes occurred after the ${
              ZOOM_FACTOR * 100
            }% mark and won't be visible on the zoomed bar.`
          );
        }

        // Sort buzzes to ensure we process them in time order
        visibleBuzzes.sort((a, b) => a.time_ms - b.time_ms);

        // --- SIMPLE STAGGERING LOGIC ---
        const LEVEL_1_TOP = 2; // Upper line
        const LEVEL_2_TOP = 18; // Lower line (16px difference)
        // --- END SIMPLE STAGGERING LOGIC ---

        visibleBuzzes.forEach((b, index) => {
          // All calculations must use MAX_DURATION_MS as the denominator (100%)
          const pct = (b.time_ms / MAX_DURATION_MS) * 100;
          const markerLeft = pct + "%";

          // 1. CREATE MARKER (The line in the progress bar)
          const markerEl = document.createElement("div");
          markerEl.className = "marker";
          markerEl.style.left = markerLeft;
          markerEl.dataset.time = b.time_ms;
          markerEl.dataset.revealed = "false";
          markerEl.dataset.labelId = `label-${index}`;

          markers.appendChild(markerEl);

          // 2. CREATE LABEL (The name above the bar)
          const labelEl = document.createElement("div");
          labelEl.className = "markerLabel";

          // Use the index to alternate vertical level
          const adjustedTop = index % 2 === 0 ? LEVEL_1_TOP : LEVEL_2_TOP;

          labelEl.id = `label-${index}`;
          labelEl.style.left = markerLeft; // Position horizontally
          labelEl.style.top = adjustedTop + "px"; // Position vertically
          labelEl.innerHTML = `${escapeHtml(b.name)}<br>${(
            b.time_ms / 1000
          ).toFixed(2)}s`;

          markerLabels.appendChild(labelEl);
        });

        // 2. Start the loop that handles progress and revelation
        // We pass the new MAX_DURATION_MS to the loop for accurate bar movement
        startRevealLoop(true, MAX_DURATION_MS);
      };

      // Reset
      resetBtn.onclick = () => {
        buzzes = [];
        markers.innerHTML = "";
        bar.style.width = "0%";
        progressWrap.style.display = "none";
        roundActive = false;
        renderBuzzList();
        stateInfo.textContent = "Buzzes reset";
      };

      // render buzz list
      function renderBuzzList() {
        buzzListEl.innerHTML = "";
        buzzes.forEach((b) => {
          const div = document.createElement("div");
          div.className = "buzzItem";
          div.innerHTML = `<div>${escapeHtml(b.name)}</div><div>${(
            b.time_ms / 1000
          ).toFixed(2)} s</div>`;
          buzzListEl.appendChild(div);
        });
      }

      // reveal loop: polls player.getCurrentState() to update progress bar and optionally reveal markers
      async function startRevealLoop(revealMarkers = false, maxDuration = 0) {
        if (revealRAF) cancelAnimationFrame(revealRAF);
        progressWrap.style.display = "block";

        async function tick() {
          if (!player) {
            revealRAF = requestAnimationFrame(tick);
            return;
          }
          const state = await player.getCurrentState();
          if (
            !state ||
            !state.track_window ||
            state.track_window.current_track == null
          ) {
            // If state is unavailable, continue polling
            revealRAF = requestAnimationFrame(tick);
            return;
          }

          const pos = state.position; // ms

          // FIX: Determine the correct maximum duration to use for the progress bar calculation
          // If maxDuration was passed (for reveal mode), use it. Otherwise, use the track's full duration.
          const currentMaxDur =
            maxDuration > 0 ? maxDuration : state.duration || 1;

          // Calculate progress bar percentage using the determined max duration
          const pct = Math.min(100, (pos / currentMaxDur) * 100);
          bar.style.width = pct + "%";

          if (revealMarkers) {
            // If the playback position exceeds the reveal window (e.g., pos > 25% mark),
            // pause the player to prevent the bar from sitting at 100% indefinitely.
            if (pos > currentMaxDur) {
              if (!state.paused) {
                player.pause();
                stateInfo.textContent = "Replay finished.";
              }
            }

            const kids = Array.from(markers.children);

            kids.forEach((k) => {
              const tt = parseInt(k.dataset.time || "0", 10);
              const revealed = k.dataset.revealed === "true";

              // Trigger reveal only if position has passed the time AND it hasn't been revealed yet
              if (!revealed && pos >= tt) {
                const labelId = k.dataset.labelId;
                const labelEl = document.getElementById(labelId);

                // Force re-animation logic
                k.classList.remove("active");
                if (labelEl) labelEl.classList.remove("active");

                void k.offsetHeight;
                if (labelEl) void labelEl.offsetHeight;

                k.classList.add("active");
                if (labelEl) labelEl.classList.add("active");

                k.dataset.revealed = "true";
              }
            });
          }

          // continue loop while playing
          if (!state.paused) {
            revealRAF = requestAnimationFrame(tick);
          } else {
            // if paused, keep polling once per 250ms to detect resumed playback
            setTimeout(() => {
              revealRAF = requestAnimationFrame(tick);
            }, 250);
          }
        }
        tick();
      }

      // Start round: clears buzzes, plays and enables buzz button
      startRoundBtn.onclick = async () => {
        if (!loadedTrackUri) return alert("Load a track URI first");
        if (!deviceId)
          return alert(
            "Player not ready. Make sure the SDK initialized and a device ID was obtained."
          );

        buzzes = [];
        renderBuzzList();
        markers.innerHTML = "";
        markerLabels.innerHTML = "";
        progressWrap.style.display = "block";
        bar.style.width = "0%";

        // Start playback at 0 and check for API errors
        try {
          const success = await playOnDevice(loadedTrackUri, 0);

          if (success) {
            roundActive = true;
            stateInfo.textContent =
              "Round started — buzzes enabled (Full Playback)";

            // FIX: Call startRevealLoop without a maxDuration parameter.
            // It will default to the player's full duration in the loop.
            startRevealLoop(false);
          } else {
            alert("Playback initiation failed (Unknown API error).");
            stateInfo.textContent = "Round failed to start.";
          }
        } catch (e) {
          alert(
            "Could not start round. Check player state and Premium status. Error: " +
              e.message
          );
          console.error("Start Round Error:", e);
          stateInfo.textContent =
            "Round failed to start (See console for API error).";
        }
      };

      // small helper
      function escapeHtml(s) {
        return String(s).replace(
          /[&<>"']/g,
          (c) => ({ "&": "&", "<": "<", ">": ">", '"': '"', "'": "" }[c])
        );
      }

      // Kick off initialization
      window.addEventListener("load", initFromCallback);

      // keyboard mapping: space for buzz
      window.addEventListener("keydown", (e) => {
        if (e.code === "Space") {
          e.preventDefault();
          buzzBtn.click();
        }
      });
    </script>
  </body>
</html>
